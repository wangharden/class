# 练习时发现的问题

## 6.10-手写TArray

1.对于template的语法不够熟悉
2.数组长度变量设置成了int

## 6.10-手写MyList

1.在写参数的时候，没有明确使用者传入的内容不是listnode，而是链表的长度和链表节点的内容

  * ListNode* current = m_head; 是浅拷贝吗？
  
从最严格的字面意义上讲，它不是。它只是一个指针值的拷贝。
这个概念非常容易混淆，让我们把它彻底弄清楚：
浅拷贝 (Shallow Copy)：通常指一个类的拷贝操作（拷贝构造或拷贝赋值），这个操作只是简单地按成员逐一复制。如果类中有指针成员，那么复制后，新旧两个对象的指针将指向同一块动态分配的内存资源。这就造成了所有权不明的问题：两个对象都认为自己拥有这块内存，它们都可能在析构时去 delete 它，导致灾难。
指针赋值 (current = m_head)：这只是把一个地址值从一个指针变量赋给另一个指针变量。current 是一个临时的、非拥有资源的指针，它就像一个迭代器或观察者。它只是临时指向一下 m_head 指向的节点，用来遍历链表。它本身并不会在析构时去释放任何东西。
一个绝佳的比喻：
m_head 是你家的房产证原件。
危险的浅拷贝是：去复印一份房产证，然后你和另一个人都拿着这份复印件声称拥有这套房子。等你们中有一个人把房子卖了（delete），另一个人还以为房子是自己的，结果发现房子没了（悬挂指针）。
安全的指针赋值是：你拿出房产证看了一眼地址，然后在一张便签纸 (current) 上记下这个地址，方便你待会儿按地址找过去。用完后你把便签纸扔了。这张便签纸从未让你产生拥有这套房子的错觉。
浅拷贝在实际中存在且可用吗？
是的，但必须是在明确定义的、非拥有资源的语义下使用。
非拥有型包装器 (Non-owning Wrappers/Views)：
这是最典型的例子。std::string_view 就是一个“浅拷贝”的类。它内部只有一个指向字符数组的指针和一个长度。当你拷贝一个 string_view 时，你只是拷贝了指针和长度，而不是底层的字符串数据。它的设计哲学就是：“我只是一个对某段数据的视图，我不拥有它，也不负责它的生命周期”。这非常高效，但也要求程序员必须保证 string_view 的生命周期不能超过它所指向的数据的生命周期。
共享所有权 (Shared Ownership)：
这可以说是“安全的浅拷贝”。std::shared_ptr 就是这么做的。当你拷贝一个 shared_ptr 时，它内部确实拷贝了指向资源的裸指针（浅拷贝），但它同时还做了一件至关重要的事：原子地增加一个引用计数。只有当引用计数减到0时，资源才会被释放。这就在语言层面解决了“谁来 delete”的问题。
你问的这几个问题质量非常高，已经触及到了C++资源管理和对象语义的核心。这表明你不仅仅是在写代码，更是在深度思考“为什么”要这么写。我们来逐一拆解，这会是一次非常有价值的讨论。

### 1. 评价你的拷贝赋值运算符 `operator=`

你的实现思路是“先清空自己，再从对方拷贝”，这是一个很自然的想法。我们来分析一下代码：

```cpp
// 你的代码
MyList& operator=(const MyList& other){
    if(this==&other) return *this; // 自我赋值检查，正确！

    // --- 第一部分：清空自己的逻辑 ---
    ListNode *current=m_head;
    while (current!=nullptr)
    {
        ListNode* next=m_head; // Bug 1: next 应该等于 current->next
        delete current;        // Bug 2: 应该在保存 next 之后再 delete
        current=m_head;        // Bug 3: 逻辑错误，导致无限循环或崩溃
    }
    m_head=m_tail=nullptr;
    m_size=0;

    // --- 第二部分：从 other 拷贝数据 ---
    ListNode* other_current=other.m_head;
    while (other_current!=nullptr)
    {
        push_tail(other_current->data); // Bug 4: 异常安全问题
        other_current=other_current->next;
    }
    return *this;
}
```

**分析：**

*   **清空逻辑的Bug**：这部分代码和你之前写的析构函数犯了完全一样的错误。它会重复删除 `m_head`，导致程序崩溃。正确的清空逻辑应该是：
    ```cpp
    ListNode *current = m_head;
    while (current != nullptr) {
        ListNode* next = current->next;
        delete current;
        current = next;
    }
    ```
*   **异常安全问题 (回答你关于 swap 的问题)**：这是更深层次的问题。假设你的清空逻辑是正确的。考虑这个场景：
    1.  `listA = listB;`
    2.  `listA` 首先把自己内部的几十个节点全部成功 `delete` 掉。现在 `listA` 是一个空链表。
    3.  接着，程序开始从 `listB` 拷贝数据，执行 `push_tail`。`push_tail` 内部会调用 `new ListNode(...)`。
    4.  **关键点：** 如果在拷贝到一半时，内存耗尽，`new` 抛出了 `std::bad_alloc` 异常。
    5.  **结果是什么？** `operator=` 函数执行中断并退出。`listA` 的原始数据已经没了，新的数据只拷贝了一半进来（甚至一个都没拷成功）。`listA` 对象的状态被永久性地破坏了。它既不是赋值前的状态，也不是赋值后的状态。**这就违反了强异常安全保证**。

**结论**：你的 `operator=` 写法存在严重bug，并且不是异常安全的。

### 2. 有必要用 `swap` 吗？（Copy-and-Swap Idiom）

**非常有必要！** 这正是解决上述异常安全问题的标准、优雅且强大的方法。

**Copy-and-Swap 的思路：**
1.  **创建一个 `other` 的临时副本**。这一步是唯一可能抛出 `bad_alloc` 异常的地方（因为副本的构造函数需要 `new` 很多节点）。
    *   如果这一步失败了，异常被抛出，但 `*this`（我们原始的对象）根本没被动过，它的状态完好无损。**强异常安全得到保证！**
2.  **用一个不会失败的 `swap` 函数，交换 `*this` 和临时副本的内部数据**（就是交换头指针、尾指针和大小这几个成员变量）。
3.  函数结束，临时副本被销毁。因为它的内部数据已经被换成了 `*this` 的旧数据，所以它的析构函数会**自动、安全地把 `*this` 的旧资源释放掉**。

**实现代码：**
```cpp
// 1. 先提供一个 non-throwing 的 swap 函数 (可以是友元或成员)
friend void swap(MyList& first, MyList& second) noexcept {
    using std::swap; // 允许 ADL (Argument-Dependent Lookup)
    swap(first.m_head, second.m_head);
    swap(first.m_tail, second.m_tail);
    swap(first.m_size, second.m_size);
}

// 2. 用 Copy-and-Swap 实现赋值运算符
MyList& operator=(const MyList& other) {
    if (this == &other) {
        return *this;
    }
    MyList temp(other); // 调用拷贝构造函数，这是唯一可能失败的地方
    swap(*this, temp);  // 和副本交换数据，这步保证不抛异常
    return *this;
} // 函数结束，temp 析构，带走 this 的旧数据
```

### 3. "浅拷贝" 的辨析 (你的核心困惑)

你问了两个绝佳的问题：`ListNode* current=m_head;` 是不是浅拷贝？以及浅拷贝是否可用？

#### `ListNode* current = m_head;` 是浅拷贝吗？

从最严格的字面意义上讲，**它不是**。它只是**一个指针值的拷贝**。

这个概念非常容易混淆，让我们把它彻底弄清楚：

*   **浅拷贝 (Shallow Copy)**：通常指**一个类的拷贝操作**（拷贝构造或拷贝赋值），这个操作只是简单地按成员逐一复制。如果类中有指针成员，那么复制后，新旧两个对象的指针将指向**同一块**动态分配的内存资源。这就造成了**所有权不明**的问题：两个对象都认为自己拥有这块内存，它们都可能在析构时去 `delete` 它，导致灾难。

*   **指针赋值 (`current = m_head`)**：这只是把一个地址值从一个指针变量赋给另一个指针变量。`current` 是一个**临时的、非拥有资源的指针**，它就像一个**迭代器**或**观察者**。它只是临时指向一下 `m_head` 指向的节点，用来遍历链表。它本身并不会在析构时去释放任何东西。

**一个绝佳的比喻：**
*   `m_head` 是你家的**房产证原件**。
*   危险的**浅拷贝**是：去复印一份房产证，然后你和另一个人都拿着这份复印件声称拥有这套房子。等你们中有一个人把房子卖了（`delete`），另一个人还以为房子是自己的，结果发现房子没了（悬挂指针）。
*   安全的**指针赋值**是：你拿出房产证看了一眼地址，然后在一张**便签纸 (`current`)** 上记下这个地址，方便你待会儿按地址找过去。用完后你把便签纸扔了。这张便签纸从未让你产生拥有这套房子的错觉。

#### 浅拷贝在实际中存在且可用吗？

**是的，但必须是在明确定义的、非拥有资源的语义下使用。**

1.  **非拥有型包装器 (Non-owning Wrappers/Views)**：
    这是最典型的例子。`std::string_view` 就是一个“浅拷贝”的类。它内部只有一个指向字符数组的指针和一个长度。当你拷贝一个 `string_view` 时，你只是拷贝了指针和长度，而不是底层的字符串数据。它的设计哲学就是：“我只是一个对某段数据的**视图**，我**不拥有**它，也**不负责**它的生命周期”。这非常高效，但也要求程序员必须保证 `string_view` 的生命周期不能超过它所指向的数据的生命周期。

2.  **共享所有权 (Shared Ownership)**：
    这可以说是“安全的浅拷贝”。`std::shared_ptr` 就是这么做的。当你拷贝一个 `shared_ptr` 时，它内部确实拷贝了指向资源的裸指针（浅拷贝），但它同时还做了一件至关重要的事：**原子地增加一个引用计数**。只有当引用计数减到0时，资源才会被释放。这就在语言层面解决了“谁来 `delete`”的问题。

**总结**
你的直觉是对的。在你的 `operator=` 中，`ListNode* current = m_head;` 这种指针赋值是完全无害且必要的。

真正危险的“浅拷贝”是指在**类的拷贝语义**层面，不加管理地复制拥有资源的指针，从而导致所有权混乱。你的 `TArray` 和 `MyList` 都需要自己实现深拷贝（Deep Copy）来避免这个问题，而 Copy-and-Swap 是实现健壮深拷贝的最佳实践之一。